       实验一

1.解决问题：计算两个字符串或数值组成的序列的最长公共子序列

2.运用算法：动态规划算法

  动态规划应用于找出最优子结构的问题，最优子结构既局部最优解能决定全局最优解。

3.算法实现：
 
  首先，创建两个序列：
  Xi=<x1,...,xi>,表明X序列的前i个字符，(1<=i<=m)
  Yj=<y1,...,yj>,既为Y序列的前j个字符，(1<=j<=n)
  在X、Y序列中找出最长公共子序列
  假设最长公共子序列是为Zk=<zi,...,zk>，Zk的长度为k
  因为X、Y序列是假设出来的，我们并不知道其中具体的字符是什么，所以我们要简化问题，我们可以先把问题转化为求Zk的长度问题。

  1）假设X序列的最后一个字符xm和Y序列的最后一个字符yn相等，既xm=yn:用反证法可以证明，Zk(最长公共子序列)的最后一个字符zk=xm=yn，因为Zk∈LCS(X,Y) , 所以Zk-1∈LCS（Xm-1,Yn-1),Z的前缀Zk-1是Xi-1序列和Yj-1序列的最长公共子序列。所以Zk的长度等于LCS（Xi-1,Yj-1）的长度加1

  2）假设X序列的最后一个字符xm和Y序列的最后一个字符yn不相等，既xm≠yn:用反证法可以证明，Zk要么Z∈LCS(Xm-1, Y)，要么Zk∈LCS(X , Yn-1)。由于zk≠xm与zk≠yn其中至少有一个必成立，若zk≠xm则有Z∈LCS(Xm-1 , Y)，以此类推

    如果zk≠yn 则有Z∈LCS(X , Yn-1)。所以问题变成了求LCS(Xm-1 , Y)和 LCS(X , Yn-1)的长度。在这两种情况下，需要选择长度最长的序列，既max{LCS(Xm-1 , Y)的长度, LCS(X , Yn-1)的长度}。



4.举例填写数组单元格：
  
  填写过程中记录下当前单元格的数字来自于哪个单元格，以方便最后回溯找出最长公共子串。有时候左上、左、上三者中有多个

  同时达到最大，那么任取其中之一，但是在整个过程中你必须遵循固定的优先标准。在我的代码中优先级别是左上>上>左。
  
  以下是我自己举的一个例子：
  
             
  
  
5. 程序代码：

Procedure LCS_LENGTH(X,Y);
begin
  m:=length[X];
  n:=length[Y];
  for i:=1 to m do c[i,0]:=0;
  for j:=1 to n do c[0,j]:=0;
  for i:=1 to m do
    for j:=1 to n do
      if x[i]=y[j] then
        begin
          c[i,j]:=c[i-1,j-1]+1;
          b[i,j]:="I";
        end
      else if c[i-1,j]>=c[i,j-1] then
        begin
          c[i,j]:=c[i-1,j];
          b[i,j]:="↑";
        end
      else
        begin
          c[i,j]:=c[i,j-1];
          b[i,j]:="←"
        end;
  return(c,b);

   
  
   
   